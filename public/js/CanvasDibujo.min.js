// Canvas de dibujo
let canvas = document.getElementById("canvasDibujo");
let ctx = canvas.getContext("2d");
let dibujando = false;
let colorActual = "#000000";
let herramienta = "pincel";
let historial = [];
let figuras = [];
let figuraSeleccionada = null;
let redimensionando = false;
let moviendo = false;
let puntoAncla = null;
let offsetX = 0;
let offsetY = 0;
let ultimoX = 0;
let ultimoY = 0;

const colorPicker = document.getElementById("colorPicker");
const herramientaSelect = document.getElementById("herramienta");

colorPicker.addEventListener("input", e => colorActual = e.target.value);
herramientaSelect.addEventListener("change", e => herramienta = e.target.value);

document.getElementById("borrarLienzo").addEventListener("click", () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    historial = [];
    figuras = [];
});

document.getElementById("deshacer").addEventListener("click", () => {
    if (historial.length > 0) {
        figuras.pop();
        historial.pop();
        redibujar();
    }
});

document.getElementById("guardarDibujo").addEventListener("click", () => {
    let imagen = canvas.toDataURL("image/jpeg");
    let enlace = document.createElement("a");
    enlace.download = "dibujo.jpg";
    enlace.href = imagen;
    enlace.click();
});

canvas.addEventListener("mousedown", e => {
    let { x, y } = obtenerPosicion(e);
    const resultado = detectarFiguraConPuntoDeControl(x, y);

    if (resultado) {
        figuraSeleccionada = resultado.figura;
        puntoAncla = resultado.ancla;

        if (puntoAncla) {
            redimensionando = true;
            canvas.style.cursor = "nwse-resize";
        } else {
            moviendo = true;
            offsetX = x - figuraSeleccionada.x;
            offsetY = y - figuraSeleccionada.y;
            canvas.style.cursor = "move";
        }
    } else {
        dibujando = true;
        historial.push(ctx.getImageData(0, 0, canvas.width, canvas.height));

        if (herramienta === "pincel") {
            ultimoX = x;
            ultimoY = y;
        } else {
            let figura = {
                tipo: herramienta,
                x: x,
                y: y,
                w: 0,
                h: 0,
                color: colorActual
            };
            figuras.push(figura);
        }
    }
});

canvas.addEventListener("mousemove", e => {
    let { x, y } = obtenerPosicion(e);

    if (dibujando) {
        if (herramienta === "pincel") {
            ctx.strokeStyle = colorActual;
            ctx.lineWidth = 2;
            ctx.lineCap = "round";

            ctx.beginPath();
            ctx.moveTo(ultimoX, ultimoY);
            ctx.lineTo(x, y);
            ctx.stroke();

            ultimoX = x;
            ultimoY = y;
        } else {
            let figura = figuras[figuras.length - 1];
            figura.w = x - figura.x;
            figura.h = y - figura.y;
            redibujar();
        }
    } else if (redimensionando && figuraSeleccionada) {
        figuraSeleccionada.w = x - puntoAncla.x;
        figuraSeleccionada.h = y - puntoAncla.y;
        redibujar();
    } else if (moviendo && figuraSeleccionada) {
        figuraSeleccionada.x = x - offsetX;
        figuraSeleccionada.y = y - offsetY;
        redibujar();
    } else if (figuraSeleccionada) {
        canvas.style.cursor = "move";
    } else {
        canvas.style.cursor = "default";
    }
});

canvas.addEventListener("mouseup", () => {
    dibujando = false;
    redimensionando = false;
    moviendo = false;
    figuraSeleccionada = null;
    puntoAncla = null;
    canvas.style.cursor = "default";

    if (herramienta === "pincel") {
        historial.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
    }
});

function redibujar() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    figuras.forEach(fig => {
        ctx.fillStyle = fig.color;
        switch (fig.tipo) {
            case "rect":
                ctx.fillRect(fig.x, fig.y, fig.w, fig.h);
                break;
            case "circle":
                ctx.beginPath();
                ctx.ellipse(
                    fig.x + fig.w / 2,
                    fig.y + fig.h / 2,
                    Math.abs(fig.w / 2),
                    Math.abs(fig.h / 2),
                    0, 0, 2 * Math.PI
                );
                ctx.fill();
                break;
            case "triangle":
                ctx.beginPath();
                ctx.moveTo(fig.x, fig.y + fig.h);
                ctx.lineTo(fig.x + fig.w / 2, fig.y);
                ctx.lineTo(fig.x + fig.w, fig.y + fig.h);
                ctx.closePath();
                ctx.fill();
                break;
        }
    });
}

function obtenerPosicion(e) {
    const rect = canvas.getBoundingClientRect();
    return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
    };
}

function detectarFiguraConPuntoDeControl(x, y) {
    for (let i = figuras.length - 1; i >= 0; i--) {
        const f = figuras[i];
        const margen = 10;
        const bordeX = f.x + f.w;
        const bordeY = f.y + f.h;

        const dentro = (
            x >= f.x &&
            x <= f.x + f.w &&
            y >= f.y &&
            y <= f.y + f.h
        );

        const enEsquinaInferiorDerecha =
            x >= bordeX - margen && x <= bordeX + margen &&
            y >= bordeY - margen && y <= bordeY + margen;

        if (dentro) {
            if (enEsquinaInferiorDerecha) {
                return { figura: f, ancla: { x: f.x, y: f.y } }; // redimensionar
            }
            return { figura: f, ancla: null }; // mover
        }
    }
    return null;
}
